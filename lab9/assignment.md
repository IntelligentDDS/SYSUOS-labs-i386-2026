# 实验要求

> - DDL：2026.6.17 23:59:59
> - 提交的内容：将 **4 个 Assignment 的代码**和**实验报告**放到**压缩包**中，命名为 "**lab9-姓名-学号**"，并交到课程网站上
> - **材料的代码放置在 `src` 目录下**。
> - Assignment 1-3 为必做（共 100 分），Assignment 4 为选做加分。

1. 实验不限语言，C/C++/Rust 都可以。
2. 实验不限平台，Windows、Linux（含银河麒麟 ARM64）和 MacOS 等都可以。
3. 实验不限 CPU，ARM/Intel/RISC-V 都可以。

---

## Assignment 1 — 磁盘驱动与 FAT16 基础（30 分）

### 1.1 复现并理解磁盘驱动（15 分）

复现 `src/1` 的代码，完成以下内容：

1. 成功编译并运行示例代码（`make image && make build && make run`），截图展示 FAT16 文件系统演示的运行结果。
2. **结合代码逐步分析** ATA PIO 磁盘读写的完整流程：
   - `waitReady()` 如何通过轮询状态寄存器（0x1F7）等待磁盘就绪
   - `selectSector()` 如何设置 LBA 地址（0x1F3-0x1F6）和扇区数（0x1F2）
   - `readSectors()` 中发送 READ 命令（0x20）后，如何通过 16-bit 端口 I/O（`asm_in_port_word`）从数据寄存器（0x1F0）读取 256 个字（512 字节 = 1 扇区）
   - `writeSectors()` 的写入流程与读取流程的异同
3. 解释为什么数据寄存器（0x1F0）使用 16 位 I/O（`in ax, dx`）而不是 8 位 I/O（`in al, dx`）。

### 1.2 分析 FAT16 文件系统布局（15 分）

结合代码和 `fat16.h` 中的常量定义，回答以下问题：

1. 画出本实验中磁盘的完整布局图（从扇区 0 到数据区），标明每个区域的起始扇区号和大小。
2. FAT 表的每个条目占多少字节？总共有多少个条目？最多能管理多少个数据簇？
3. 根目录区最多能存放多少个文件？每个目录条目的大小是多少？
4. 如果一个文件占用了簇 5 → 簇 8 → 簇 12，那么 FAT 表中 `FAT[5]`、`FAT[8]`、`FAT[12]` 的值分别是什么？
5. 解释 `clusterToSector()` 函数中 `FS_START_SECTOR + DATA_START_OFFSET + (cluster - 2)` 的计算逻辑，为什么簇号从 2 开始？

---

## Assignment 2 — 文件操作实现分析（35 分）

### 2.1 文件创建与写入（15 分）

阅读 `fat16.cpp` 中 `createFile()` 和 `writeFile()` 的实现，完成以下内容：

1. 结合代码分析 `createFile("hello.txt")` 的执行流程：
   - `toFAT16Name` 如何将 `"hello.txt"` 转换为 8.3 格式 `"HELLO   TXT"`
   - 如何在根目录区查找空闲条目（`findFreeEntry()`）
   - 目录条目中各字段如何初始化
2. 结合代码分析 `writeFile("hello.txt", data, size)` 的执行流程：
   - 如何计算需要分配多少个簇
   - `allocateCluster()` 如何在 FAT 表中查找空闲簇
   - 如何构建 FAT 链（簇 A → 簇 B → EOF）
   - 数据如何通过 `disk->writeSectors()` 写入对应扇区
   - 为什么写完数据后必须调用 `syncFAT()` 将 FAT 表同步到磁盘
3. 如果对已存在的文件调用 `writeFile`（覆盖写），旧数据的簇链如何被释放？

### 2.2 文件读取与删除（12 分）

阅读 `fat16.cpp` 中 `readFile()` 和 `deleteFile()` 的实现，完成以下内容：

1. 结合代码分析 `readFile("hello.txt", buffer, maxSize)` 的执行流程：
   - 如何从目录条目获取文件的起始簇号和文件大小
   - 如何通过 FAT 链逐簇读取数据
   - 读取过程在什么条件下停止（FAT 链终止 或 已达 maxSize）
2. 结合代码分析 `deleteFile("data.bin")` 的执行流程：
   - `freeClusterChain()` 如何沿着 FAT 链释放所有簇
   - 目录条目如何被标记为"已删除"（首字节设为 0xE5）
   - 删除文件后，文件数据是否真的从磁盘上擦除了？为什么？

### 2.3 自定义文件操作测试（8 分）

修改 `shell.cpp` 中的 `runDemo()` 函数，添加以下测试：

1. 创建至少 5 个文件，向每个文件写入不同的内容
2. 列出所有文件，验证文件名和大小正确
3. 读取每个文件并打印内容，验证数据一致性
4. 删除部分文件后重新创建同名文件，验证被删除条目的空间能被重新利用

截图展示运行结果。

---

## Assignment 3 — 文件系统功能扩展（35 分）

### 3.1 文件追加写入（15 分）

当前 `writeFile` 是覆盖写模式——每次写入都会释放旧数据并重新分配簇。请实现一个新的函数：

```cpp
bool FAT16::appendFile(const char *name, const char *data, uint32 size);
```

功能要求：
1. 如果文件不存在，行为与 `writeFile` 相同（创建并写入）
2. 如果文件已存在，在文件末尾追加数据：
   - 找到 FAT 链的最后一个簇
   - 如果最后一个簇还有剩余空间，先填满它
   - 分配新的簇并链接到 FAT 链末尾
   - 更新目录条目中的 `fileSize`
3. 在 `runDemo()` 中测试：对同一个文件多次追加写入，然后读取验证内容完整

### 3.2 磁盘空间统计（8 分）

实现以下功能函数：

```cpp
// 返回指定文件占用的簇数
int FAT16::getFileClusterCount(const char *name);

// 返回文件系统的碎片率 (0.0 ~ 1.0)
// 碎片率 = 不连续的簇分配次数 / 总簇分配次数
float FAT16::getFragmentation();
```

在演示中创建多个文件、删除部分文件、再创建新文件，展示碎片率的变化。

### 3.3 文件重命名（12 分）

实现文件重命名功能：

```cpp
bool FAT16::renameFile(const char *oldName, const char *newName);
```

功能要求：
1. 验证旧文件存在且新文件名不冲突
2. 修改目录条目中的文件名和扩展名
3. 不需要移动文件数据或修改 FAT 链
4. 在演示中测试重命名功能

---

## Assignment 4 — 选做加分（最高 20 分）

以下任选其一或多个完成，每小项最高 5-10 分。

### 4.1 交互式 Shell（10 分）

在当前示例中，Shell 仅自动执行预设的演示流程。请实现一个**交互式 Shell**：

1. 添加键盘中断处理（IRQ 1），实现基本的字符输入
2. 实现命令行输入缓冲区和简单的命令解析
3. 支持以下命令：
   - `ls` — 列出所有文件
   - `cat <filename>` — 显示文件内容
   - `touch <filename>` — 创建空文件
   - `write <filename> <content>` — 写入文件
   - `rm <filename>` — 删除文件
   - `info` — 显示文件系统信息
   - `format` — 格式化文件系统
   - `help` — 显示帮助信息

提示：
- 键盘中断处理可参考 8042 PS/2 键盘控制器，端口 0x60 (数据) 和 0x64 (状态)
- 需要扫描码到 ASCII 的转换表
- Shell 主循环中可使用信号量或忙等待来等待用户输入

### 4.2 子目录支持（10 分）

扩展当前的平面目录结构，支持子目录：

1. 实现 `mkdir` / `rmdir` 操作
2. 子目录也使用 FAT 链分配簇来存储目录条目
3. 实现路径解析（如 `"dir1/file.txt"`）
4. 支持 `.`（当前目录）和 `..`（上级目录）条目
5. 修改 `listFiles` 以支持列出指定目录的内容

### 4.3 大文件支持与性能优化（5 分）

1. 创建一个超过 1 个簇（512 字节）的文件，验证跨簇读写的正确性
2. 实现多扇区批量读写优化：当连续簇号相邻时，合并为一次多扇区 I/O 操作
3. 对比优化前后的性能（可通过计数端口操作次数来衡量）

### 4.4 文件系统一致性检查（5 分）

实现 `fsck()` 功能，检查文件系统的一致性：

1. 检查所有被文件引用的簇是否正确标记在 FAT 表中
2. 检查是否存在"丢失的簇"（FAT 中标记为已使用但无文件引用）
3. 检查是否存在交叉链接（多个文件引用同一个簇）
4. 输出检查报告

---

## 思考题（不计分，鼓励思考）

1. 在真实的 FAT16 文件系统中，BPB（BIOS Parameter Block）存储在哪里？它与我们的 SuperBlock 有什么区别？
2. FAT16 的最大卷大小限制是多少？这个限制来源于哪些因素？FAT32 如何突破这些限制？
3. 我们的实现使用 PIO 模式进行磁盘 I/O，这意味着 CPU 必须全程参与数据传输。DMA（Direct Memory Access）模式如何改进这一点？
4. 当前实现将整个 FAT 表缓存在内核内存中。如果 FAT 表非常大（如 FAT32），这种策略还可行吗？如何改进？
5. 文件系统的日志（journaling）机制如何防止意外断电导致的数据不一致？Ext4 的日志机制与 FAT 文件系统的应对策略有何不同？
6. 我们使用 `0xE5` 标记删除文件，但文件数据并未真正擦除。这对数据恢复和数据安全意味着什么？如何实现安全删除？
