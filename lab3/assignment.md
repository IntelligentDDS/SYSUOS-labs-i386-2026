# Lab3 保护模式

# 实验要求

**请注意，今年的实验有部分改动，与往年不一样，请大家千万不要抄袭往年的代码；如果使用大模型写的代码，也请务必标注出来，老师和助教会有查重，以避免抄袭行为！**

实验的DDL是 **2026.04.07 23:59**

## 实验环境

本实验支持在 **Ubuntu** 和 **麒麟操作系统（Kylin OS）** 上完成。

**基础工具安装：**

| 工具 | Ubuntu | 麒麟OS |
|------|--------|--------|
| 汇编器 + 模拟器 | `sudo apt install nasm qemu-system-x86 gdb make` | `sudo yum install nasm qemu-system-x86_64 gdb make` |

> **说明：**
> - 如果麒麟OS上没有 `qemu-system-i386` 命令，可使用 `qemu-system-x86_64` 代替，效果完全一致。
> - NASM 是跨平台的 x86 汇编器，在 ARM64 架构上也能正确编译 x86 汇编代码。
> - ARM64 上的 GDB 可能不支持 x86 远程调试（仅支持 AArch64），此时可使用 **QEMU Monitor** 作为替代调试工具，详见 [README.md 的"再论debug"一节](./README.md)。

1. 实验不限语言， C/C++/Rust都可以。
2. 实验不限平台， Windows、Linux和MacOS等都可以。
3. 实验不限CPU， ARM/Intel/Risc-V都可以。

**本次实验中，代码要求并不高（主要为复现任务），主要希望同学们掌握保护模式、段地址的知识，同时学习gdb调试的方法，并在调试的过程中，学习到操作系统内核的知识与注意事项。**

## 提交内容

将 **4个 Assignment 的代码** 和 **实验报告** 放到 **压缩包** 中，命名为"**lab3-姓名-学号.zip**"，并交到[课程网站](http://course.dds-sysu.tech/course/18/homework)上。

实验报告中请注明你的实验环境（操作系统版本、CPU架构），并对每个 Assignment 说明实现思路和结果截图。

> **材料的Example的代码放置在`src`目录下**。



## Assignment 1 磁盘加载

### 1.1

复现Example 1，说说你是怎么做的并提供结果截图，也可以参考Ucore、Xv6等系统源码，实现自己的LBA方式的磁盘访问。
> 在这个lab的`src`文件夹中，提供了makefile文件，同学们可以自行学习通过`make`的方法，更快捷地完成编译、运行任务。

> **麒麟OS用户提示：** `src`中的makefile已支持自动检测QEMU命令（`qemu-system-i386` 或 `qemu-system-x86_64`），直接使用 `make build && make run` 即可。

### 1.2

在Example1中，我们使用了LBA28的方式来读取硬盘。此时，我们只要给出逻辑扇区号即可，但需要手动去读取I/O端口。然而，BIOS提供了实模式下读取硬盘的中断，其不需要关心具体的I/O端口，只需要给出逻辑扇区号对应的磁头（Heads）、扇区（Sectors）和柱面（Cylinder）即可，又被称为CHS模式。现在，同学们需要将LBA28读取硬盘的方式换成CHS读取，同时给出逻辑扇区号向CHS的转换公式。最后说说你是怎么做的并提供结果截图。

参考资料：

- [CHS和LBA的换算小记](https://zhuanlan.zhihu.com/p/608292324)
- [int 13h中断](https://blog.csdn.net/brainkick/article/details/7583727)

其中，关键参数如下。

| 参数                             | 数值 |
| -------------------------------- | ---- |
| 驱动器号（DL寄存器）             | 80h  |
| 每磁道扇区数                     | 63   |
| 每柱面磁头数（每柱面总的磁道数） | 18   |

> **提示（LBA → CHS 转换公式）：**
> - 柱面号 $C = \lfloor LBA \div (SPT \times HPC) \rfloor$
> - 磁头号 $H = \lfloor LBA \div SPT \rfloor \mod HPC$
> - 扇区号 $S = (LBA \mod SPT) + 1$
>
> 其中 SPT = 每磁道扇区数，HPC = 每柱面磁头数。注意 CHS 的扇区号从1开始，而LBA从0开始。

### 1.3 加载校验

在 Example 1 中，MBR 只是简单地跳转到 bootloader。现在请修改 MBR，使得在加载 bootloader 之后、跳转之前，先**校验**加载的内容是否正确。

具体要求：
1. 在你的 bootloader 末尾放置一个4字节的**魔数**（magic number），例如 `0xCAFEBABE`。
2. MBR 在读取完所有扇区后，从内存中检查该魔数是否存在且正确。
3. 如果校验通过，输出 "BOOT OK" 并跳转到 bootloader；如果校验失败，输出 "BOOT ERR" 并停机（`hlt`）。

> **提示：** 你需要计算魔数在内存中的偏移地址。假设 bootloader 被加载到 `0x7e00`，大小为 N 字节，则魔数位于 `0x7e00 + N - 4` 处。可以使用 `cmp dword [addr], 0xCAFEBABE` 来比较。

> 说说你是怎么做的，并将结果截图。建议同时截图校验通过和校验失败（可以故意写入错误的 bootloader 数据来触发失败）两种情况。

## Assignment 2 保护模式分析

### 2.1 调试保护模式

复现Example 2，使用gdb或其他debug工具在进入保护模式的4个重要步骤上设置断点，并结合代码、寄存器的内容等来分析这4个步骤，最后附上结果截图。gdb的使用可以参考[appendix的“debug with gdb and qemu”部份](../appendix/debug_with_gdb_and_qemu/README.md)。

进入保护模式的4个关键步骤是：
1. **加载GDT** — 使用 `lgdt` 指令加载全局描述符表
2. **打开A20地址线** — 写端口 `0x92` 或通过键盘控制器
3. **设置CR0的PE位** — `or eax, 1` + `mov cr0, eax`
4. **远跳转进入保护模式** — `jmp dword code_selector:protect_mode_begin`

> 在这个lab的`src`文件夹中，同样提供了makefile文件，同学们可以自行学习通过`make`的方法，更快捷地完成debug任务。

> **ARM64 平台（麒麟OS等）调试说明：**
> 如果你的GDB不支持x86远程调试（执行 `set architecture i8086` 报错），可以使用 **QEMU Monitor** 作为替代方案：
> ```shell
> # 启动QEMU并开启Monitor
> qemu-system-x86_64 -drive file=hd.img,format=raw -display none \
>     -monitor telnet:127.0.0.1:4444,server,nowait &
> sleep 2
> # 连接Monitor
> ncat 127.0.0.1 4444
> # 查看寄存器，验证保护模式
> (qemu) info registers
> ```
> 使用 `info registers` 命令可以看到段选择子、GDT信息和CR0状态，同样能验证保护模式的4个步骤。详细用法参见 [README.md 的"再论debug"一节](./README.md)。

### 2.2 手工解析段描述符

Example 2 的 GDT 中有5个描述符（含空描述符），请从**内存转储或调试器输出**中读取第2个描述符（数据段，GDT偏移 `0x08`）的原始8字节十六进制内容，然后**手工解析**出以下字段，并在报告中写出完整的解析过程：

| 字段 | 说明 |
|------|------|
| 段基地址（Base） | 32位，分散在描述符的3个部分中 |
| 段界限（Limit） | 20位，分散在描述符的2个部分中 |
| G（粒度位） | 0=字节，1=4KB |
| D/B位 | 0=16位，1=32位 |
| S位 | 0=系统段，1=代码/数据段 |
| TYPE字段 | 4位，说明段类型（可读/可写/可执行等） |
| DPL | 特权级（0~3） |
| P（存在位） | 段是否在内存中 |

> **提示：** 段描述符8个字节的布局参见 README.md 中的段描述符结构图。低4字节先存放（小端序），使用GDB的 `x /2xw GDT地址+8` 或 QEMU Monitor 的 `xp /2xw 0x8808` 可以读取原始内容。

> 通过这个解析过程，思考一下Linux-0.11的存储方式，是小端存储还是大端存储呢？

### 2.3 自定义段描述符

在 Example 2 的基础上，向 GDT 中**新增一个段描述符**（第6个描述符，GDT偏移 `0x28`），要求：

1. 该段为**数据段**，基地址为 `0x7000`，段界限为 `0x1FFF`，粒度为字节，DPL=0。
2. 将对应的选择子（`0x28`）加载到 `FS` 寄存器中。
3. 在保护模式下，通过 `FS` 段寄存器向偏移地址 `0` 处（即物理地址 `0x7000`）写入一个标识字符串（如你的学号）。然后通过 `DS` 段（0~4GB平坦数据段）读取物理地址 `0x7000` 处的内容并输出到屏幕上，验证两种段访问方式指向了同一物理地址。

> **提示：**
> - 新增的段选择子值为 `0x28`（第6个描述符，索引5 × 8 = 0x28），记得同步修改 GDTR 的界限值（从 39 改为 47，即 `6×8-1`）。
> - 通过 `FS:0` 访问的物理地址 = FS段基地址 + 偏移0 = `0x7000 + 0` = `0x7000`。
> - 通过 `DS:0x7000` 访问的物理地址 = DS段基地址 + 偏移0x7000 = `0 + 0x7000` = `0x7000`。
> - 这两种方式都指向同一物理地址，体现了保护模式下段式寻址的核心原理。
> - 构造段描述符时，需要将基地址和界限按照段描述符格式拆分到对应的位域中，参考 README.md 中段描述符结构图。

## Assignment 3 32位保护模式编程

### 3.1 移植 Lab2 程序到保护模式

改造“Lab2-Assignment 4”为32位代码，即在加载到保护模式后执行自定义的汇编程序。

> 提示：
> ①在lab2中使用中断来实现功能的同学，现在会出错，为什么？怎么解决？
> ②在lab2中直接将字符输出到qemu显存的同学，如果直接复制粘贴代码，同样也会出错，为什么？怎么解决？

> **详细提示：**
> - **关于中断：** 进入保护模式后，BIOS的实模式中断向量表（IVT）已经不再有效。如果之前使用 `int 10h`、`int 16h` 等BIOS中断，需要改为直接操作硬件（如直接写VGA显存 `0xb8000`，直接操作I/O端口等）。
> - **关于显存访问：** 在实模式中，`0xb8000` 地址可以通过段:偏移（如 `gs:偏移`）直接访问。在保护模式中，你需要确保 GS（或其他段寄存器）加载了正确的段选择子，且该段的基地址对应 `0xb8000`。查看 Example 2 中 GDT 的第4个描述符（视频段），理解如何正确设置。
> - **关于32位代码：** 注意使用 `[bits 32]` 伪指令，以及32位寄存器（`eax`、`ebx` 等）。

### 3.2 实现 32 位十六进制内存转储函数

在保护模式下，编写一个**十六进制内存转储（hex dump）子程序** `hex_dump`，功能如下：

- **输入：** `ESI` = 起始内存地址，`ECX` = 要显示的字节数
- **输出：** 在屏幕上以十六进制格式显示指定内存区域的内容

显示格式示例（假设从地址 `0x7C00` 开始 dump 16 字节）：
```
7C00: EA 05 7C 00 00 00 00 00 B8 00 B8 8E E8 B4 03 B9
```

具体要求：
1. 每行显示起始地址（4位十六进制）+ 冒号 + 16字节的十六进制内容
2. 每个字节用两位十六进制表示（不足两位需补零），字节间用空格分隔
3. 使用保护模式下的 VGA 显存（`GS` 段）输出
4. 程序需使用 `call`/`ret` 实现为可复用的子程序

> **提示：**
> - 这个任务的核心是**将一个字节转为两个十六进制ASCII字符**。可以用位移（`shr`）和掩码（`and`）取高低4位，然后查表或计算得到 `'0'-'9'` 或 `'A'-'F'`。
> - 一种简洁的实现方式是构造一个16字节的查找表 `hex_table db '0123456789ABCDEF'`，用 `mov al, [hex_table + nibble]` 来转换。
> - 地址的显示同理，将32位地址的低16位按4个nibble依次输出。
> - 此任务可以和 3.1 放在同一个 bootloader 中，在32位模式下先运行 hex dump 显示一段内存，再执行 3.1 的程序。

请在报告中展示对 **GDT 所在内存区域**（地址 `0x8800` 开始，至少32字节）的 hex dump 输出截图，并与 Assignment 2.2 的手工解析结果进行对比验证。

## Assignment 4 综合应用（选做，附加分）

设计一个**保护模式下的简易内存浏览器**，实现以下功能：

1. 进入保护模式后，在屏幕上显示某一地址开始的内存内容（hex dump 格式，可复用 Assignment 3.2 的子程序）。
2. 通过**键盘输入**控制内存浏览：
   - 按 `↓` 或 `j`：向后翻一页（地址增加 256 字节）
   - 按 `↑` 或 `k`：向前翻一页（地址减少 256 字节）
   - 按 `q`：停机退出
3. 屏幕上同时显示当前查看的起始地址。

> **说明：** 保护模式下无法使用 BIOS 键盘中断 `int 16h`，需要直接操作键盘控制器的 I/O 端口来读取按键。

> **键盘 I/O 端口提示：**
> - 端口 `0x64`（状态寄存器）：bit 0 为1时表示输出缓冲区有数据可读
> - 端口 `0x60`（数据端口）：读取按键的扫描码
> - 读取步骤：先检查 `0x64` 端口的 bit 0，如果为1，再从 `0x60` 端口读取扫描码
> - 方向键的扫描码：`↑` = `0x48`，`↓` = `0x50`；字母键：`j` = `0x24`，`k` = `0x25`，`q` = `0x10`
>
> ```asm
> ; 示例：等待并读取一个按键扫描码
> wait_key:
>     in al, 0x64
>     test al, 1
>     jz wait_key       ; 输出缓冲区为空，继续等待
>     in al, 0x60       ; 读取扫描码到 AL
> ```

> **参考：** 可以将屏幕想象为一个终端窗口，每次翻页时清屏并重新绘制。清屏可以通过向整个VGA显存区域写入空格字符来实现。

# 参考资料

- 《从实模式到保护模式》：第8.3.3节~8.3.5节，第11章，第12.4节。
- Intel® 64 and IA-32 Architectures Software Developer's Manual, Vol. 3A, Chapter 3 (Protected-Mode Memory Management)
- [OSDev Wiki: Protected Mode](https://wiki.osdev.org/Protected_Mode)
- [OSDev Wiki: Global Descriptor Table](https://wiki.osdev.org/Global_Descriptor_Table)
- [OSDev Wiki: "8042" PS/2 Controller](https://wiki.osdev.org/%228042%22_PS/2_Controller)
- [OSDev Wiki: VGA Hardware](https://wiki.osdev.org/VGA_Hardware)