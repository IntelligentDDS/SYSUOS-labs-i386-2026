# 内核线程

> 古今之成大事者，不惟有超世之才，亦必有坚韧不拔之志。

# 实验要求

**请注意，今年的实验有部分改动，与往年不一样，请大家千万不要抄袭往年的代码；如果使用大模型写的代码，也请务必标注出来，老师和助教会有查重，以避免抄袭行为！**

实验的DDL是 **2026.05.06 23:59**

## 实验环境

本实验支持在 **Ubuntu** 和 **麒麟操作系统（Kylin OS）** 上完成。

| 项目 | Ubuntu AMD64 | 银河麒麟 ARM64 |
|------|-------------|----------------|
| C/C++编译器 | `gcc/g++ -m32` | `i686-elf-gcc/g++`（交叉编译） |
| 链接器 | `ld -melf_i386` | `i686-elf-ld -melf_i386` |
| 二进制工具 | `objcopy` | `i686-elf-objcopy` |
| QEMU | `qemu-system-i386` | `qemu-system-x86_64` |
| 调试器 | `gdb` | `gdb-multiarch` 或 QEMU Monitor |

> **说明：** `src/3` 和 `src/4` 的 Makefile 已实现自动检测。`src/1` 和 `src/2` 是宿主机程序，在银河麒麟上直接使用系统 `g++` 编译（去掉 `-m32` 参数即可）。

## 提交内容

将 **5个 Assignment 的代码** 和 **实验报告** 放到 **压缩包** 中，命名为"**lab5-姓名-学号.zip**"，并交到[课程网站](http://course.dds-sysu.tech/course/18/homework)上。

实验报告中请注明你的实验环境（操作系统版本、CPU架构），并对每个 Assignment 说明实现思路和结果截图。

> **材料的Example的代码放置在`src`目录下**。

1. 实验不限语言， C/C++/Rust都可以。
2. 实验不限平台， Windows、Linux和MacOS等都可以。
3. 实验不限CPU， ARM/Intel/Risc-V都可以。

---

## Assignment 1 printf的实现

### 1.1 基本printf

学习可变参数机制，然后实现printf。你可以在材料中的printf上进行改进（提示：可以增加一些格式化输出类型），或者从头开始实现自己的printf函数。结果截图并说说你是怎么做的。

### 1.2 增强printf

在1.1的基础上，为你的printf至少增加以下**两种**格式化输出支持（也可以全部实现）：

1. **`%o`**：按八进制输出无符号整数。
2. **`%u`**：按十进制输出无符号整数（注意与`%d`的区别——`%d`是有符号的）。
3. **`%p`**：按指针格式输出地址（输出形如`0x0001A2B3`，即16进制带`0x`前缀，至少8位，高位补零）。
4. **`%0Nd`**（*选做*）：输出至少N位的十进制数，不足N位时高位补零。例如 `printf("%08d", 42)` 输出 `00000042`。

> **提示：** `%o` 和 `%u` 的实现与 `%d` / `%x` 类似，只需修改 `itos` 函数的进制参数即可。`%p` 需要处理前缀 `0x` 和固定宽度输出。

请在内核环境（`src/3`的基础上）中测试你的printf，在`setup_kernel`中编写测试语句，验证各种格式化输出的正确性，截图并说明。

## Assignment 2 线程的实现

### 2.1 基本线程

自行设计PCB，可以添加更多的属性，如优先级等，然后根据你的PCB来实现线程，演示执行结果。

### 2.2 多线程并发展示

创建**至少3个线程**，每个线程在屏幕的**不同行**分别打印不同的内容（例如线程名称和计数器），使它们通过时间片轮转调度交替执行。要求：

1. 每个线程的输出应有明确的标识（如线程名、PID），以便区分。
2. 至少让3个线程运行足够长的时间（可以使用循环），使得能够观察到线程切换的效果。
3. 在实验报告中说明你观察到的线程调度行为：哪个线程先执行？线程是如何交替的？

> **提示：** 可以让每个线程在循环中打印自己的PID和一个递增计数器。使用 `printf` 输出到屏幕的不同位置（例如线程1打印在第1行，线程2打印在第5行，线程3打印在第10行）。你可以通过直接操作VGA显存来控制输出位置。

## Assignment 3 线程调度切换的秘密

操作系统的线程能够并发执行的秘密在于我们需要中断线程的执行，保存当前线程的状态，然后调度下一个线程上处理机，最后使被调度上处理机的线程从之前被中断点处恢复执行。现在，同学们可以亲手揭开这个秘密。

### 3.1 跟踪线程切换

编写若干个线程函数，使用gdb跟踪`c_time_interrupt_handler`、`asm_switch_thread`等函数，观察线程切换前后栈、寄存器、PC等变化，结合gdb、材料中"线程的调度"的内容来跟踪并说明下面两个过程。

- 一个新创建的线程是如何被调度然后开始执行的。
- 一个正在执行的线程是如何被中断然后被换下处理器的，以及换上处理机后又是如何从被中断点开始执行的。

通过上面这个练习，同学们应该能够进一步理解操作系统是如何实现线程的并发执行的。

> **银河麒麟ARM64用户提示：** 如果没有图形界面无法使用 `gdb -tui`，可以：
> - 使用 `make debug` 配合 `gdb-multiarch`（纯命令行模式）。
> - 使用 QEMU Monitor 查看寄存器状态：`info registers` 查看当前CPU寄存器。
> - 使用 `xp /Nbx <addr>` 查看内存/栈内容。
> - 在实验报告中记录你使用的调试方法和观察到的结果。

### 3.2 分析线程栈布局

结合gdb调试和材料中对`asm_switch_thread`的分析，**画出**以下两个时刻的线程栈布局图（在报告中手绘或使用工具绘制）：

1. 一个**新创建尚未执行**的线程的栈布局（对应材料中的"第一种情况"）。
2. 一个**被中断后保存了上下文**的线程的栈布局（对应"第二种情况"）。

在每种情况下，标注出：
- `esp` 指向的位置
- `ebp`、`ebx`、`edi`、`esi` 保存的位置
- 函数地址 `function`、返回地址 `program_exit`、参数 `parameter` 的位置
- `ret` 指令执行后 `eip` 的变化

> **提示：** 回顾材料中 `executeThread` 函数对 `thread->stack` 的初始化过程（stack[0]~stack[6]分别是什么），以及 `asm_switch_thread` 中 push/pop 对栈的影响。

## Assignment 4 调度算法的实现

在材料中，我们已经学习了如何使用时间片轮转算法来实现线程调度。但线程调度算法不止一种，例如

- 先来先服务。
- 最短作业（进程）优先。
- 响应比最高者优先算法。
- 优先级调度算法。
- 多级反馈队列调度算法。

此外，我们的调度算法还可以是抢占式的。

### 4.1 实现一种调度算法

将线程调度算法修改为上面提到的算法或者是同学们自己设计的算法。然后，同学们需要自行编写测试样例来呈现你的算法实现的正确性和基本逻辑。最后，将结果截图并说说你是怎么做的。

> **提示：**
> - 先来先服务最简单——线程一旦上处理机就执行完毕后才让出。
> - 有些调度算法的实现**可能需要**用到中断。
> - 参考资料：[https://zhuanlan.zhihu.com/p/97071815](https://zhuanlan.zhihu.com/p/97071815)

### 4.2 对比分析

设计**同一组测试线程**（至少3个线程，各自有不同的执行时间和优先级），分别在**两种不同的调度算法**下运行（例如RR和优先级调度），对比并分析：

1. 各线程的执行顺序有何不同？
2. 各线程的等待时间和周转时间有何差异？
3. 两种算法各自的优缺点是什么？

在报告中给出截图、表格或数据对比，并用自己的话总结分析。

> **提示：** 可以为每个线程设置不同的 `ticks`（代表执行时间）和 `priority`，在线程函数中使用 `printf` 打印当前线程名和 `ticksPassedBy`。通过观察输出顺序和时间片消耗来分析调度行为。

## Assignment 5 线程的生命周期管理（选做加分题）

实现完整的线程生命周期管理，包括**线程的主动让出（yield）和阻塞/唤醒（sleep/wakeup）**机制。要求：

### 5.1 实现 `thread_yield`

实现一个 `void thread_yield()` 函数，使当前运行的线程主动放弃CPU，让调度器选择下一个就绪线程执行。要求：

1. 调用 `thread_yield` 后，当前线程应被放回就绪队列尾部。
2. 线程的 `ticks` 不清零（与时间片耗尽的调度不同——yield是主动让出，而非被强制调度）。

### 5.2 实现 `thread_sleep` 和 `thread_wakeup`

实现线程的阻塞和唤醒机制：

1. `void thread_sleep(List *waitList)`：将当前线程的状态设置为 `BLOCKED`，并将其加入到指定的等待队列 `waitList` 中，然后调度下一个线程执行。
2. `void thread_wakeup(PCB *thread, List *waitList)`：将指定的阻塞线程从等待队列中移除，将其状态设置为 `READY`，放入就绪队列。

编写测试用例验证：

- 创建至少2个线程，一个线程调用 `thread_sleep` 进入阻塞，另一个线程在合适的时机调用 `thread_wakeup` 唤醒它。
- 在报告中展示线程状态的变化过程。

> **提示：** 
> - `thread_yield` 的实现类似 `schedule`，但不需要改变 `ticks`。
> - `thread_sleep` 需要将线程从就绪队列移除，加入等待队列，然后调用 `schedule`。
> - `thread_wakeup` 需要从等待队列移除线程并加入就绪队列。
> - 这些操作都需要在关中断的保护下进行。
> - 这些机制是后续实现信号量和锁的基础。

---

# 参考资料

- [可变参数函数详解](https://www.cnblogs.com/clover-toeic/p/3736748.html)
- [调度算法](https://zhuanlan.zhihu.com/p/97071815)
- 有时间的同学可以了解 [ghOSt](https://github.com/google/ghost-userspace)
- 《操作系统真象还原》
