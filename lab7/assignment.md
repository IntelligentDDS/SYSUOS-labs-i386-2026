# 实验要求

> - DDL：2026.5.27 23:59:59
> - 提交的内容：将 **4 个 Assignment 的代码**和**实验报告**放到**压缩包**中，命名为 "**lab7-姓名-学号**"，并交到课程网站上
> - **材料的代码放置在 `src` 目录下**。
> - Assignment 1-3 为必做（共 100 分），Assignment 4 为选做加分。

1. 实验不限语言，C/C++/Rust 都可以。
2. 实验不限平台，Windows、Linux（含银河麒麟 ARM64）和 MacOS 等都可以。
3. 实验不限 CPU，ARM/Intel/RISC-V 都可以。

---

## Assignment 1 — 物理页内存管理与分页机制（40 分）

### 1.1 复现物理页内存管理（15 分）

复现 `src/3` 的物理页内存管理代码，在 `first_thread` 中编写测试代码：

1. 分别从内核物理地址池和用户物理地址池中分配若干页（如 10 页、20 页、50 页），打印分配的起始地址。
2. 释放部分页后再次分配，验证释放的空间是否可被复用。
3. 截图展示运行结果，并**结合代码逐步分析** BitMap → AddressPool → MemoryManager 三层管理结构的初始化过程和分配/释放流程。

### 1.2 开启二级分页机制（15 分）

复现 `src/4` 的代码，开启二级分页机制，完成以下内容：

1. 结合代码分析开启分页机制的三步方案：(a) 初始化页目录表和页表，(b) 将页目录表地址写入 CR3，(c) 将 CR0 的 PG 位置 1。
2. 说明 `directory[0]`、`directory[768]`、`directory[1023]` 三个页目录项各自的作用以及为什么要这样设置。
3. 使用 QEMU Monitor 的 `info mem` 命令，截图展示开启分页机制后的虚拟地址映射关系，验证 0~1MB 的恒等映射是否正确建立。

### 1.3 Bug 检测与修复（10 分）

构造**至少 3 组测试用例**来检测物理页内存管理（`src/3`）或虚拟页内存管理（`src/5`）的实现是否存在 bug。测试用例应包含：

- 边界情况：分配 0 页、分配超过总页数的页
- 重复释放：对同一块内存连续释放两次
- 碎片化测试：交替分配和释放，观察地址复用情况

如果发现 bug，尝试修复并说明修复方案；如果未发现 bug，结合测例分析实现的正确性。

---

## Assignment 2 — 动态分区分配算法（30 分）

### 2.1 实现至少两种分配算法（20 分）

在操作系统内核中（可基于 `src/3` 或 `src/5` 扩展），实现以下动态分区分配算法中的**至少两种**：

- **First Fit**（首次适应）：从头开始，找到第一个足够大的空闲分区
- **Best Fit**（最佳适应）：找到最小的足够大的空闲分区
- **Worst Fit**（最坏适应）：找到最大的空闲分区
- **Next Fit**（循环首次适应）：从上次分配位置开始搜索

要求：
1. 可以直接修改 BitMap/AddressPool 的 `allocate` 函数实现不同策略，也可以新建独立模块。
2. 在 `first_thread` 中进行多次分配和释放操作，**打印每次分配的起始地址和分区大小**。
3. 截图并对比两种算法在相同分配序列下的行为差异（地址分布、碎片情况）。

### 2.2 内存利用率分析（10 分）

设计一个内存分配序列（至少包含 8 次分配 + 4 次释放），在每次操作后统计并打印以下指标：

- 已分配页数 / 总页数
- 最大连续空闲块大小（页数）
- 空闲碎片数量（不连续的空闲块个数）

对比你实现的两种算法在该序列下的内存利用率和碎片情况，给出分析。

> **提示**：可以在 BitMap 类中添加 `getUsedCount()`、`getMaxFreeBlock()`、`getFreeFragmentCount()` 等统计函数。

---

## Assignment 3 — 虚拟页内存管理与地址变换（30 分）

### 3.1 复现虚拟页内存管理（10 分）

复现 `src/5` 的代码，完成以下内容：

1. 结合代码分析虚拟页内存分配的三步过程：(a) 从虚拟地址池分配连续虚拟页，(b) 从物理地址池为每个虚拟页分配物理页，(c) 建立页目录项和页表项。
2. 在 `first_thread` 中分配多组虚拟页（如 100 页、10 页、100 页），打印虚拟地址；释放中间的 10 页后重新分配，观察地址变化。

### 3.2 PDE/PTE 虚拟地址构造（10 分）

在 `src/5` 的 `openPageMechanism` 中，我们将第 1023 个页目录项指向了页目录表本身。现在考虑如下场景：

1. **假设**将指向页目录表本身的页目录项改为第 **1000** 个（而不是第 1023 个），请推导：
   - 第 **141** 个页目录项的虚拟地址
   - 第 **891** 个页目录项指向的页表中，第 **109** 个页表项的虚拟地址
2. 写出你的推导过程和最终结果（十六进制）。

### 3.3 虚拟地址到物理地址的验证（10 分）

在 `first_thread` 中：

1. 使用 `allocatePages` 分配一段内核虚拟内存（如 1 页）。
2. 调用 `vaddr2paddr` 计算该虚拟地址对应的物理地址，打印两者。
3. 向该虚拟地址写入一个特定的值（如 `0xDEADBEEF`）。
4. 使用 QEMU Monitor 的 `xp` 命令查看物理地址处的值，验证虚拟地址到物理地址的映射是否正确。

截图展示程序输出和 QEMU Monitor 验证结果。

---

## Assignment 4 — 选做加分（最高 15 分）

以下任选其一或多个完成，每小项最高 5 分。

### 4.1 页面置换算法模拟（5 分）

在操作系统内核中模拟页面置换。假设物理页帧有限（如只有 8 帧），实现以下算法之一：

- **FIFO**（先进先出）
- **LRU**（最近最少使用）
- **Clock**（时钟算法）

给定一组虚拟页访问序列，打印每次访问时是否发生缺页、被淘汰的页号、当前帧内容。统计缺页率。

### 4.2 内存统计面板（5 分）

在 `src/5` 的基础上，实现一个内存统计函数 `printMemoryStatus()`，在屏幕上显示：

- 物理内存总量、已分配量、空闲量
- 内核物理地址池 / 用户物理地址池 / 内核虚拟地址池的使用率
- 已建立的页目录项数量、页表项数量

### 4.3 自定义内存管理（5 分）

参考 uCore、《操作系统真象还原》或《一个操作系统的实现》等资料，实现自己的物理页或虚拟页内存管理方案（如 Buddy System、Slab Allocator 等）。指出你的实现相比教程的特点和优势。

---

## 思考题（不计分，鼓励思考）

1. 相比于一级页表，二级页表的好处是什么？在什么情况下二级页表的空间开销反而更大？
2. 如果将功能号 `0xe801` 的 `0x15` 中断改为 `0xe820`，需要修改哪些代码？`0xe820` 的优势是什么？
3. 在多进程环境下，如何保证不同进程的虚拟地址空间互不干扰？页目录表和页表在其中扮演什么角色？
4. 请用自己的话说说我们是如何通过一个指向页目录表的页目录项来构造 PDE 和 PTE 的虚拟地址的。
