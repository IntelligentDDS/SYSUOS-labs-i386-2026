# lab4 混合编程与中断

# 实验要求

**请注意，今年的实验有部分改动，与往年不一样，请大家千万不要抄袭往年的代码；如果使用大模型写的代码，也请务必标注出来，老师和助教会有查重，以避免抄袭行为！**

实验的DDL是 **2026.04.22 23:59**

## 实验环境

本实验支持在 **Ubuntu** 和 **麒麟操作系统（Kylin OS）** 上完成。

| 项目 | Ubuntu AMD64 | 银河麒麟 ARM64 |
|------|-------------|----------------|
| C/C++编译器 | `gcc/g++ -m32` | `i686-elf-gcc/g++`（交叉编译） |
| 链接器 | `ld -melf_i386` | `i686-elf-ld -melf_i386` |
| 二进制工具 | `objcopy` | `i686-elf-objcopy` |
| QEMU | `qemu-system-i386` | `qemu-system-x86_64` |
| 调试器 | `gdb` | `gdb-multiarch` 或 QEMU Monitor |

> **说明：** 所有 `src` 中的 Makefile 已实现自动检测——在 Ubuntu AMD64 上使用原生编译器，在银河麒麟 ARM64 上自动使用交叉编译器。直接使用 `make && make run` 即可。
>
> 如果你的交叉编译器尚未支持C++（即没有 `i686-elf-g++`），请参考 [README.md 的"实验环境"一节](./README.md) 重新构建。

## 提交内容

将 **5个 Assignment 的代码** 和 **实验报告** 放到 **压缩包** 中，命名为"**lab4-姓名-学号.zip**"，并交到[课程网站](http://course.dds-sysu.tech/course/18/homework)上。

实验报告中请注明你的实验环境（操作系统版本、CPU架构），并对每个 Assignment 说明实现思路和结果截图。

> **材料的Example的代码放置在`src`目录下**。

1. 实验不限语言， C/C++/Rust都可以。
2. 实验不限平台， Windows、Linux和MacOS等都可以。
3. 实验不限CPU， ARM/Intel/Risc-V都可以。

---

## Assignment 1 混合编程的基本思路

### 1.1 复现与分析

复现Example 1，结合具体的代码说明C代码调用汇编函数的语法和汇编代码调用C函数的语法。例如，结合代码说明`global`、`extern`关键字的作用，为什么C++的函数前需要加上`extern "C"`等，结果截图并说说你是怎么做的。同时，学习make的使用，并用make来构建Example 1，结果截图并说说你是怎么做的。

> **麒麟OS用户提示：** Example 1使用了`<stdio.h>`和`<iostream>`，需要宿主机标准库支持。在ARM64上交叉编译器不提供标准库，此例主要用于理解编译和链接过程。你可以使用`i686-elf-objdump -d`查看生成的汇编代码来验证调用关系，或者参考1.2题的做法将Example 1改造为不依赖标准库的版本。

### 1.2 带参数的混合编程

在Example 1的基础上，实现一个**带参数和返回值**的混合编程例子：

1. 编写一个**汇编函数** `int asm_add(int a, int b)`，功能是返回 $a + b$。
2. 在C/C++中调用该函数并验证结果。
3. 编写一个**C函数** `int c_multiply(int a, int b)`，功能是返回 $a \times b$。
4. 在汇编代码中调用该C函数，将两个参数压栈后用`call`调用，并将返回值（在`eax`中）保存。

> **提示：** 回顾教材中C/C++函数调用规则：参数从右向左入栈，返回值放在`eax`中。汇编函数需要通过`[ebp+8]`、`[ebp+12]`等方式获取参数。

说说你的实现思路，并截图展示结果。

## Assignment 2 使用C/C++来编写内核

### 2.1 复现与修改

复现Example 2，在进入`setup_kernel`函数后，将输出 "Hello World" 改为输出你的**学号**，结果截图并说说你是怎么做的。

### 2.2 实现 `print_string` 函数

在Example 2的基础上，实现一个C/C++函数 `void print_string(const char *str, uint8 color)`，功能是在VGA屏幕上以指定颜色输出字符串。要求：

1. 函数直接操作VGA显存（起始地址`0xb8000`），支持指定颜色属性。
2. 使用该函数在屏幕的不同行输出至少3行不同颜色的文本（例如：白色的学号、绿色的姓名拼音、红色的日期）。
3. 简单说明VGA文本模式下字符和颜色属性在显存中的存储格式。

> **提示：** VGA文本模式下，每个字符占2字节：低字节是ASCII码，高字节是颜色属性。颜色属性的低4位是前景色，高4位是背景色。例如`0x0A`表示黑底绿字，`0x0C`表示黑底红字。

## Assignment 3 中断的处理

> 在过去的一个多月里，经常有同学来问助教为什么自己的程序会出现段错误（Segmentaton Fault），助教觉得这是一个值得深刻思考的问题，决定继续~~用段错误折磨大家~~让大家深入学习段错误的成因，同时让大家稍微提前地学习到内存管理的部分相关知识。

### 3.1 实现页面错误中断处理

请在`src/8`的基础上，仿照Example 3编写段错误的中断处理函数，助教已经在`src/8/src/kernel/setup.cpp`中实现了对应的段错误触发语句，只要你正确实现段错误的中断处理并正确地在中断描述符中注册即可。

> 因为必须引入内存管理之后，才会有段错误（其实是**页面错误**），所以助教引入了一些lab7中的页面管理代码（memory.cpp等），同学们可以忽略这部分的代码，暂时不要求掌握。

结果截图并说说你是怎么做的。

### 3.2 读取CR2寄存器获取缺页地址

在3.1的基础上，进一步完善你的页面错误处理函数，使其能够**读取CR2寄存器**，获取并打印引发页面错误的虚拟地址。

> **提示：** 当页面错误发生时，CPU会自动将引发错误的虚拟地址存入CR2寄存器。你可以编写一个汇编函数来读取它：
>
> ```asm
> ; uint32 asm_read_cr2()
> global asm_read_cr2
> asm_read_cr2:
>     mov eax, cr2
>     ret
> ```
>
> 然后在C/C++的中断处理函数中调用它，将获取到的地址打印到屏幕上。验证该地址是否与`setup.cpp`中触发错误的地址（如`0x100000`）一致。

### 3.3 思考题

**额外思考题**（写在实验报告中即可）：

1. 请你使用尽可能多的方法触发段错误，并在你的实验报告里总结一下，引发段错误都有哪几种方式。
2. 大家在实现完段错误的中断处理函数之后，可能会发现类似于"数组越界"这样的典型错误都无法引起段错误中断，这是"正常"现象，但请你想想，这是为什么？（提示：可以通过gdb等方法打印对应地址的值，并以此为角度思考为何尽管"越界"了，但仍然不中断报错）
3. 在你的实验报告中，总结一下，哪些行为会真正地引起段错误中断；而哪些行为在理论上（以及在真正的C++程序中）会引起段错误，但却没有在你的内核中引起段错误中断。

下面简单地介绍一下页表机制，作为该思考题的提示。

设想你是精灵王国的国王，王国幅员辽阔，精灵们必须通过传送门（页表）回家。他们只需输入住处编号（虚拟地址），传送门便会根据映射关系，将他们送往真实的居所（物理地址）。例如，输入住处编号 0x114，传送门会指引他们到王国第 0x514 号土地上的房屋。然而，精灵们会生老病死、搬迁迁徙，住处编号与土地编号的对应关系也需不断更新，因此，国王必须及时登记新住址、注销旧住址，以确保传送门的映射始终正确。（即虚拟地址到物理地址的映射关系需实时更新）。

理解了上述的简单小故事，也就不难理解页表的思想了。我们回归页管理（可以查看一下`kernel/memory.cpp`的第28-33行），我们实际上对0-1MB的内存映射到页表的前256页（也即登记了这些住处），而其他地址还未进行注册，也即虚拟内存地址大于等于`0x100000`的，都没有登记，所以在`/kernel/setup.cpp`中的`*(int*)0x100000 = 1;`代码，实际上访问到了一个没有登记的住处编号（在开启页表后，我们就再也看不到物理地址了，这里的`0x100000`也是虚拟地址），所以导致了段错误（页面错误）。

## Assignment 4 时钟中断

### 4.1 字符回旋

复现Example 4，仿照Example中使用C语言来实现时钟中断的例子，利用C/C++、 InterruptManager、STDIO或者还可以通过你自己封装的类来实现你的时钟中断处理过程，并通过这样的时钟中断，**使用C/C++语言**来复刻lab2的assignment 4 的字符回旋程序。将结果截图并说说你是怎么做的。注意，不可以使用纯汇编的方式来实现。

> 提示：在lab2和lab3实现字符回旋的时候，我们需要手动实现延时delay（无论是通过调用BIOS中断还是通过忙等的方式）。但是这里有了时钟中断之后，实际上时钟中断处理就自带了"延时"的功效了，所以我们便不必再实现delay函数。（PS：助教在前期验收的时候发现，有一些同学进入时钟中断后，直接打印了一圈的字符，这实际上是不符合该实验设计的初衷的，可以想想为什么，并进行修改）

### 4.2 自定义时钟频率

在4.1的基础上，通过对**8253/8254定时器**进行编程，修改时钟中断的频率。要求：

1. 将时钟中断频率从默认值修改为一个你自定义的值（例如100Hz或50Hz）。
2. 通过在屏幕上显示计数器的变化，验证修改后的频率是否符合预期。
3. 在报告中说明8253/8254定时器的编程方法和计算公式。

> **提示：** 8254定时器的输入时钟频率为 $1193180$ Hz。设置计数初值 $N$ 后，中断频率为：
>
> $$f = \frac{1193180}{N}$$
>
> 编程时需要向端口`0x43`写入控制字，然后向端口`0x40`分别写入计数值的低8位和高8位。示例代码：
>
> ```cpp
> // 设置8254 Channel 0, Mode 3 (方波), 二进制计数
> // 控制字: 00110110b = 0x36
> asm_out_port(0x43, 0x36);
> uint16 divisor = 1193180 / desired_frequency;
> asm_out_port(0x40, (uint8)(divisor & 0xFF));       // 低8位
> asm_out_port(0x40, (uint8)((divisor >> 8) & 0xFF)); // 高8位
> ```

## Assignment 5 键盘中断（选做加分题）

实现**键盘中断**处理程序，使你的内核能够响应键盘输入。要求：

1. 键盘使用IRQ1（即8259A主片的第1号中断），中断向量号为`0x21`。
2. 在键盘中断处理函数中，从端口`0x60`读取键盘扫描码（scan code）。
3. 将扫描码转换为对应的ASCII字符（至少支持26个字母和0-9数字），并显示在VGA屏幕上。
4. 实现一个简单的"打字机"效果：每按一个键，屏幕上显示对应的字符，光标向后移动。

> **提示：**
> - 键盘中断的启用方式类似于时钟中断，需要在8259A中取消IRQ1的屏蔽。
> - 读取扫描码：`uint8 scan_code = asm_in_port(0x60);`
> - 扫描码分为按下（make code）和释放（break code），释放码 = 按下码 + `0x80`。你只需处理按下事件即可。
> - 常见扫描码对照表（部分）：
>
> | 按键 | 扫描码 | 按键 | 扫描码 |
> |------|--------|------|--------|
> | 1    | 0x02   | Q    | 0x10   |
> | 2    | 0x03   | W    | 0x11   |
> | 3    | 0x04   | E    | 0x12   |
> | ...  | ...    | ...  | ...    |
> | 0    | 0x0B   | P    | 0x19   |
> | A    | 0x1E   | Enter| 0x1C   |
> | S    | 0x1F   | Space| 0x39   |
>
> 完整的扫描码表请自行查阅资料。
