# 实验要求

> - DDL：2026.6.10 23:59:59
> - 提交的内容：将 **4 个 Assignment 的代码**和**实验报告**放到**压缩包**中，命名为 "**lab8-姓名-学号**"，并交到课程网站上
> - **材料的代码放置在 `src` 目录下**。
> - Assignment 1-3 为必做（共 100 分），Assignment 4 为选做加分。

1. 实验不限语言，C/C++/Rust 都可以。
2. 实验不限平台，Windows、Linux（含银河麒麟 ARM64）和 MacOS 等都可以。
3. 实验不限 CPU，ARM/Intel/RISC-V 都可以。

---

## Assignment 1 — 系统调用与特权级转换（35 分）

### 1.1 复现系统调用并分析特权级机制（20 分）

复现 `src/1` 或 `src/2` 的系统调用代码，完成以下内容：

1. 编写**至少 2 个自定义系统调用**（不含已有的 `syscall_0`），例如：
   - 一个用于返回两个整数的最大值
   - 一个用于计算阶乘（迭代实现即可）
2. 在 `first_thread`（或进程）中调用你编写的系统调用，打印参数和返回值，截图展示正确性。
3. **结合代码逐步分析**系统调用的完整执行流程：
   - 用户态：`asm_system_call` 如何将参数放入寄存器并执行 `int 0x80`
   - 特权级转移：CPU 如何从 TSS 中获取内核栈地址，如何切换 SS/ESP
   - 内核态：`asm_system_call_handler` 如何根据 eax 找到系统调用表中的函数并调用
   - 返回：`iret` 如何恢复用户态的 CS/EIP/SS/ESP/EFLAGS

### 1.2 GDB 分析栈与段寄存器变化（15 分）

使用 GDB 调试 `src/3`（第一个进程），在 `int 0x80` 前后设置断点，回答以下问题：

1. 在执行 `int 0x80` **之前**，CS、SS、ESP、EIP 的值分别是什么？CPL 是多少？
2. 在进入 `asm_system_call_handler` **之后**，CS、SS、ESP 的值发生了什么变化？新的 SS 和 ESP 来自哪里？
3. 在执行 `iret` **之后**，CS、SS、ESP 恢复为什么值？这些值保存在哪里？
4. 解释 TSS 中 `esp0` 和 `ss0` 字段在上述过程中的具体作用。

> **提示**：
> - **Ubuntu AMD64**：使用 `gdb` 调试，`info registers` 查看寄存器，`x/Nwx $esp` 查看栈内容。
> - **银河麒麟 ARM64**：系统自带的 `gdb` 仅支持 aarch64 架构，无法调试 i386 目标。请改用 QEMU Monitor 完成本题：先通过 `make monitor` 启动 QEMU（无显示窗口 + Monitor 端口），然后 `telnet 127.0.0.1 <端口号>` 连接 Monitor，使用 `info registers` 查看 CS/SS/ESP/EIP/CPL 等寄存器。如需在特定位置暂停，可在代码中插入 `asm_halt()`（即 `hlt` 指令）。

---

## Assignment 2 — 进程创建与 Fork（35 分）

### 2.1 进程的创建过程分析（15 分）

复现 `src/3` 的代码，在内核线程中创建多个用户进程（至少 3 个），完成以下内容：

1. 截图展示多个进程通过系统调用输出各自信息的运行结果。
2. 结合代码分析进程创建的三步方案：
   - 第一步：如何在线程 PCB 的基础上扩展进程 PCB（分配虚拟地址空间、页目录表）
   - 第二步：如何设置 `ProcessStartStack` 使得 `asm_start_process` 能通过 `iret` 从内核态跳转到用户态
   - 第三步：`ProgramManager::schedule` 中如何实现页目录表的切换（CR3 切换）
3. 解释为什么线程的 PCB 中 `pageDirectoryAddress` 为 0，而进程的不为 0。

### 2.2 Fork 的实现与分析（20 分）

复现 `src/4` 的代码，完成以下内容：

1. 编写一个进程，在其中调用 `fork()`，父进程和子进程分别打印不同的信息（包含各自的 pid 和 fork 返回值）。截图展示运行结果。
2. **结合代码逻辑**分析 fork 如何解决以下四个关键问题：
   - 如何为子进程创建独立的虚拟地址空间（页目录表复制）
   - 如何复制父进程的用户空间数据到子进程
   - 如何设置子进程的内核栈，使其第一次被调度时能正确运行
   - 如何保证父进程的 fork 返回子进程 pid，子进程的 fork 返回 0
3. 使用 GDB（Ubuntu）或 QEMU Monitor（银河麒麟 ARM64）跟踪子进程**第一次被调度执行**的过程：
   - 在 `asm_switch_thread` 切换到子进程栈时，ESP 的地址是什么？栈中保存了什么内容？
   - 从 `asm_switch_thread` 开始，逐步跟踪子进程的跳转地址，直到子进程从 `fork` 返回用户态
   - 比较子进程的返回路径与父进程执行完 `ProgramManager::fork` 后的返回路径的异同

> **提示（银河麒麟 ARM64）**：可在关键位置（如 `asm_switch_thread` 返回后）插入 `asm_halt()` 暂停 CPU，然后用 QEMU Monitor 的 `info registers` 和 `xp` 命令查看寄存器和栈内容。

---

## Assignment 3 — Wait/Exit 与进程生命周期（30 分）

### 3.1 Exit 的实现与分析（12 分）

复现 `src/5` 的代码，完成以下内容：

1. 创建一个父进程，fork 出子进程后，子进程显式调用 `exit(42)`。截图展示运行结果。
2. 结合代码分析 `exit` 的完整执行过程：
   - 进程资源（物理页、虚拟页、页目录表）如何被释放
   - 进程状态如何从 RUNNING 变为 DEAD
   - 为什么 `exit` 最后调用 `schedule` 后，该进程不会再被调度执行
3. 解释进程的 `first_process` 函数正常返回时，为什么会**隐式调用 exit**。（提示：从 `ProcessStartStack` 的角度分析栈上保存的返回地址。）

### 3.2 Wait 的实现与父子进程同步（10 分）

复现 `src/6` 的代码，完成以下内容：

1. 创建一个父进程，fork 出**至少 2 个子进程**，每个子进程以不同的返回值调用 `exit`。父进程循环调用 `wait` 收集所有子进程的退出状态。截图展示运行结果，验证 `wait` 返回的 pid 和退出值是否正确。
2. 结合代码分析 `wait` 的执行逻辑：
   - 父进程如何遍历子进程列表寻找 DEAD 状态的子进程
   - 找到后如何回收子进程的 PCB 资源
   - 未找到时如何进入阻塞（调用 `schedule`）等待子进程退出

### 3.3 僵尸进程与孤儿进程处理（8 分）

在当前实现中存在以下问题：

1. **僵尸进程**：如果父进程从不调用 `wait`，子进程退出后 PCB 无法被回收，永远处于 DEAD 状态。
2. **孤儿进程**：如果父进程先于子进程退出，子进程变为孤儿进程，退出后无人回收。

请**对代码做出修改**，实现以下至少一种方案：

- 方案 A：实现 `init` 进程（pid=1），所有孤儿进程的父进程自动设为 init，由 init 负责回收。
- 方案 B：父进程退出时自动回收所有已经是 DEAD 状态的子进程，并将仍存活的子进程托管给其他进程。
- 方案 C：其他合理的僵尸进程回收方案。

自行测试并截图展示结果，说明你的实现思路。

---

## Assignment 4 — 选做加分（最高 15 分）

以下任选其一或多个完成，每小项最高 5 分。

### 4.1 新增系统调用：getpid 和 sleep（5 分）

在 `src/6` 或 `src/7` 的基础上，实现以下两个新的系统调用：

- `int getpid()`：返回当前进程的 pid
- `void sleep(int ticks)`：使当前进程/线程阻塞指定的时钟周期数后自动唤醒

在用户进程中测试这两个系统调用，打印各进程的 pid，并通过 sleep 实现进程间的简单同步。截图展示结果。

### 4.2 进程调度策略改进（5 分）

当前的调度策略是简单的 FCFS + 时间片轮转。请实现以下调度策略之一：

- **优先级调度**：每个进程有优先级，调度时选择优先级最高的就绪进程
- **多级反馈队列**：设置 2-3 个优先级队列，新进程进入最高优先级队列，时间片用完降级
- **短作业优先（SJF）模拟**：根据历史执行时间估计下一次 CPU burst

在用户进程中演示调度效果，对比改进前后的调度行为。

### 4.3 Shell 功能增强（5 分）

在 `src/7` 的 Shell 基础上，增加以下功能中的至少两个：

- `ps` 命令：显示当前所有进程/线程的 pid、状态、优先级
- `kill <pid>` 命令：向指定进程发送终止信号
- `exec <name>` 命令：执行一个预定义的"程序"（可以是函数指针映射）
- 命令历史记录：支持上下键浏览历史命令（需修改键盘中断处理）

截图展示运行结果，说明你的实现思路。

---

## 思考题（不计分，鼓励思考）

1. 为什么系统调用使用寄存器传递参数而不是使用栈？如果要支持超过 5 个参数的系统调用，应该如何设计？
2. 在 `ProgramManager::schedule` 中切换进程页目录表（CR3）时，为什么不会导致代码执行出错？（提示：考虑 3GB 以上的内核共享空间。）
3. Fork 出的子进程与父进程共享代码段。如果实现 Copy-on-Write（写时复制），需要修改哪些数据结构和函数？大致描述实现思路。
4. 在 Linux 中，`fork` + `exec` 是创建新进程并运行新程序的标准方式。请解释为什么不直接提供一个 `spawn` 系统调用，而是分成两步？这种设计有什么优势？

