# 并发与锁机制

# 实验概述

在本次实验中，我们首先使用硬件支持的原子指令来实现自旋锁SpinLock，自旋锁将成为实现线程互斥的有力工具。接着，我们使用SpinLock来实现信号量，最后我们使用SpinLock和信号量来给出两个实现线程互斥的解决方案。

# 实验要求

> - DDL：2026.05.20 23:59
> - 提交的内容：将**各 Assignment 的代码**和**实验报告**放到**压缩包**中，命名为"**lab6-姓名-学号**"，并交到课程网站上。
> - **材料的代码放置在`src`目录下**。

1. 实验不限语言，C/C++/Rust 都可以。
2. 实验不限平台，Windows、Linux（含银河麒麟）和 macOS 等都可以。
3. 实验不限CPU，ARM/Intel/RISC-V 都可以。

---

## Assignment 1 自旋锁与信号量复现（30 分）

### 1.1 基本复现（20 分）

在本章中，我们已经实现了自旋锁和信号量机制。现在，同学们需要：

1. 复现教程中的自旋锁（SpinLock）和信号量（Semaphore）的实现方法。
2. 分别使用自旋锁和信号量解决"消失的芝士汉堡"问题（或等价的同步互斥问题）。
3. 将结果截图并说说你是怎么做的。

### 1.2 替代锁机制实现（10 分）

我们使用了原子指令 `xchg` 来实现自旋锁。但是，这种方法并不是唯一的。例如，x86 指令中提供了另外一些原子指令和机制：

- `bts`（Bit Test and Set）指令
- `lock` 前缀（如 `lock cmpxchg`、`lock xadd`）
- 开/关中断方式（仅限单核 CPU）

现在，同学们需要：

1. 选择上述任一方式（或其他方法），实现一个**与教程实现方式不同**的锁机制。
2. 在汇编文件中实现对应的原子操作函数，并在 C++ 中封装为锁类。
3. 使用你实现的锁机制解决"消失的芝士汉堡"问题，验证其正确性。
4. **分析**你实现的锁机制与教程中 `xchg` 方式的异同，讨论各自的优缺点。

---

## Assignment 2 生产者-消费者问题（30 分）

### 2.1 展示竞态条件（10 分）

同学们需要在本教程的代码环境下，设计一个**有界缓冲区**的生产者-消费者场景：

1. 定义一个固定大小（如 5）的缓冲区数组。
2. 创建至少 **2 个生产者线程**和 **2 个消费者线程**，每个线程需要多次执行生产/消费操作。
3. **不使用**任何同步互斥工具。
4. 展示至少一种错误场景（如缓冲区溢出、消费空缓冲区、数据丢失等），说明竞态条件的危害。
5. 将结果截图并分析出错的原因。

### 2.2 使用信号量解决（15 分）

使用信号量解决 2.1 中的生产者-消费者问题：

1. 定义合适的信号量（提示：至少需要 `empty`、`full`、`mutex` 三个信号量）。
2. 确保生产者在缓冲区满时阻塞，消费者在缓冲区空时阻塞。
3. 确保生产和消费操作的互斥性。
4. 在屏幕上打印每次生产/消费的状态，包括：哪个线程在操作、缓冲区当前状态等。
5. 将结果截图并说说你是怎么做的。

### 2.3 读者-写者问题（5 分）

请同学们思考读者-写者问题，并在本教程的代码环境下创建多个线程来模拟。你需要使用**读者优先**的策略来实现同步，并通过样例设计体现写者的"饥饿"。

> 请注意：为了体现写者的"饥饿"，你可能需要创建多个读者，让他们交错地进行读者任务（进入临界区、完成一段时间的任务、退出临界区、等待一段时间再进行下一次的读者任务），而**不应该让某个读者一直在临界区中占着不出来**。

> 提示：你可能需要用到伪随机数的生成，请搜索相关资料，实现一个适合内核环境的伪随机数生成器。

---

## Assignment 3 哲学家就餐问题（30 分）

假设有 5 个哲学家，他们的生活只是思考和吃饭。这些哲学家共用一个圆桌，每位都有一把椅子。在桌子中央有五碗米饭，并在桌子上放着 5 根筷子。

![哲学家就餐问题](./gallery/哲学家就餐问题.jpeg)

当一位哲学家思考时，他与其他同事不交流。时而，他会感到饥饿，并试图拿起与他相近的两根筷子（筷子在他和他的左或右邻居之间）。一个哲学家一次只能拿起一根筷子。显然，他不能从其他哲学家手里拿走筷子。当一个饥饿的哲学家同时拥有两根筷子时，他就能吃。在吃完后，他会放下两根筷子，并开始思考。

### 3.1 初步解决方法（10 分）

1. 在本教程的代码环境下，创建 **5 个线程**分别代表 5 位哲学家。
2. 使用 **5 个信号量**分别代表 5 根筷子（初始值均为 1）。
3. 实现哲学家的"思考—饥饿—拿筷子—吃饭—放筷子"循环。
4. 在屏幕上打印每位哲学家的当前状态变化（思考/饥饿/进食）。
5. 将结果截图并说说你是怎么做的。

### 3.2 死锁演示（10 分）

虽然 3.1 的解决方案保证了两个邻居不能同时进食，但是它可能导致死锁（所有哲学家都拿起了左边的筷子，等待右边的筷子）。

1. 设计一个能**稳定复现死锁**的场景（提示：可以在拿起第一根筷子和第二根筷子之间加入延时）。
2. 在屏幕上展示死锁发生时的状态。
3. 分析死锁发生的四个必要条件在此场景中是如何满足的。

### 3.3 死锁解决方案（10 分）

提出并实现**至少一种**解决死锁的方法。常见策略包括：

- **限制同时拿筷子的哲学家数量**（最多允许 4 人同时拿筷子）
- **奇偶编号策略**（奇数号先拿左边，偶数号先拿右边）
- **同时拿起两根筷子**（原子操作）

要求：

1. 实现你选择的策略。
2. 让程序持续运行一段时间，展示**不会发生死锁**且**每位哲学家都能进食**。
3. 将结果截图，分析你的方法是如何破坏死锁四个必要条件之一的。

---

## Assignment 4 进阶选做题（加分 10 分）

> 以下题目为选做加分，最多加 10 分。

### 4.1 Hoare/Hasen 唤醒模型（5 分）

教程中实现了最简单的 MESA 模型来唤醒阻塞线程。请：

1. 根据 **Hoare 模型**或 **Hasen 模型**的描述，实现你自己的线程唤醒机制。
2. 使用该唤醒机制替换现有的 MESA 模型。
3. 设计测试用例，对比不同唤醒模型下线程执行顺序的差异。
4. 说明三种模型各自的适用场景。

### 4.2 管程实现（5 分）

请尝试在本教程的代码环境下实现**管程（Monitor）**：

1. 实现管程的基本结构：互斥锁 + 条件变量（`wait` 和 `signal` 操作）。
2. 使用管程解决一个多线程同步问题（如生产者消费者问题或哲学家就餐问题）。
3. 对比管程方案与信号量方案在代码结构上的差异。

---

## 思考题（写在实验报告中）

1. 请用自己的话说说在实现 `asm_atomic_exchange` 函数时，我们为什么需要做出"形式参数 register 指向的变量不是一个共享变量"这一重要假设。如果违反这个假设会出现什么问题？

2. 请用自己的话说说在实现信号量时，我们是如何实现线程阻塞和唤醒的。为什么 P 操作需要在循环中检查 counter？

3. 请解释为什么在单核 CPU 中可以通过开/关中断的方式来实现锁机制，而在多核 CPU 中不可以。

4. 在我们的自旋锁实现中，等待获取锁的线程会一直忙等待（busy waiting）。请分析这种方式的优缺点，并说说在什么场景下自旋锁比信号量更合适。

#  
